"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/login/page",{

/***/ "(app-pages-browser)/./src/config/api.ts":
/*!***************************!*\
  !*** ./src/config/api.ts ***!
  \***************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   authEndpoints: () => (/* binding */ authEndpoints),\n/* harmony export */   authenticatedApiCall: () => (/* binding */ authenticatedApiCall),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   flashcardEndpoints: () => (/* binding */ flashcardEndpoints),\n/* harmony export */   healthCheck: () => (/* binding */ healthCheck),\n/* harmony export */   taskEndpoints: () => (/* binding */ taskEndpoints),\n/* harmony export */   topicsEndpoints: () => (/* binding */ topicsEndpoints),\n/* harmony export */   userEndpoints: () => (/* binding */ userEndpoints),\n/* harmony export */   wordsEndpoints: () => (/* binding */ wordsEndpoints)\n/* harmony export */ });\n// unity-voice-frontend/src/config/api.ts\nconst API_URL = \"http://localhost:5000/api\" || 0;\nconsole.log('🔧 API Configuration:', {\n    NEXT_PUBLIC_API_URL: \"http://localhost:5000/api\",\n    API_URL: API_URL,\n    NODE_ENV: \"development\"\n});\n// Helper function to handle API responses\nasync function handleResponse(response) {\n    const contentType = response.headers.get('content-type');\n    console.log(\"\\uD83D\\uDCE1 Response: \".concat(response.status, \" \").concat(response.statusText, \", Content-Type: \").concat(contentType));\n    if (contentType && contentType.includes('application/json')) {\n        try {\n            const data = await response.json();\n            if (!response.ok) {\n                const errorObj = {\n                    status: response.status,\n                    statusText: response.statusText,\n                    message: data.message || data.error || 'API request failed',\n                    responseData: data,\n                    url: response.url\n                };\n                console.error('❌ API Error (JSON):', errorObj);\n                throw errorObj;\n            }\n            return data;\n        } catch (jsonError) {\n            if (!response.ok) {\n                const errorObj = {\n                    status: response.status,\n                    statusText: response.statusText,\n                    message: \"Failed to parse JSON response: \".concat(jsonError),\n                    responseData: null,\n                    url: response.url\n                };\n                console.error('❌ API Error (JSON Parse Failed):', errorObj);\n                throw errorObj;\n            }\n            throw jsonError;\n        }\n    }\n    try {\n        const text = await response.text();\n        console.log(\"\\uD83D\\uDCC4 Response text (first 200 chars): \".concat(text.substring(0, 200)));\n        if (!response.ok) {\n            const errorObj = {\n                status: response.status,\n                statusText: response.statusText,\n                message: text || 'API request failed',\n                responseData: text,\n                url: response.url\n            };\n            console.error('❌ API Error (Text):', errorObj);\n            throw errorObj;\n        }\n        return text;\n    } catch (textError) {\n        const errorObj = {\n            status: response.status,\n            statusText: response.statusText,\n            message: \"Failed to read response: \".concat(textError),\n            responseData: null,\n            url: response.url\n        };\n        console.error('❌ API Error (Text Read Failed):', errorObj);\n        throw errorObj;\n    }\n}\n// ✅ פונקציה לקבלת טוקן - תמיד מlocalStorage (פשוט יותר)\nfunction getAuthToken() {\n    if (true) {\n        return localStorage.getItem('token');\n    }\n    return null;\n}\n// ✅ Main API call function - גישה היברידית\nasync function apiCall(endpoint) {\n    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    if (!endpoint.startsWith('/')) {\n        endpoint = '/' + endpoint;\n    }\n    // ✅ הכן headers\n    const token = getAuthToken();\n    const headers = {\n        'Content-Type': 'application/json',\n        ...options.headers\n    };\n    // ✅ הוסף Authorization header אם יש טוקן\n    if (token) {\n        headers['Authorization'] = \"Bearer \".concat(token);\n    }\n    const fullUrl = \"\".concat(API_URL).concat(endpoint);\n    console.log(\"\\uD83D\\uDE80 Making API call to: \".concat(fullUrl), {\n        hasToken: !!token,\n        environment: \"development\"\n    });\n    try {\n        const response = await fetch(fullUrl, {\n            ...options,\n            headers,\n            credentials: 'include' // עדיין כולל cookies לפיתוח מקומי\n        });\n        return await handleResponse(response);\n    } catch (error) {\n        console.error(\"\\uD83D\\uDCA5 API call failed for \".concat(endpoint, \":\"), {\n            url: fullUrl,\n            error: error,\n            errorMessage: error instanceof Error ? error.message : 'Unknown error',\n            headers: headers\n        });\n        if (error && typeof error === 'object') {\n            error.endpoint = endpoint;\n            error.fullUrl = fullUrl;\n        }\n        throw error;\n    }\n}\nasync function authenticatedApiCall(endpoint) {\n    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    return apiCall(endpoint, options);\n}\nasync function healthCheck() {\n    return apiCall('/health');\n}\n// Authentication endpoints\nconst authEndpoints = {\n    login: async (credentials)=>apiCall('/auth/login', {\n            method: 'POST',\n            body: JSON.stringify(credentials)\n        }),\n    register: async (userData)=>apiCall('/auth/register', {\n            method: 'POST',\n            body: JSON.stringify(userData)\n        }),\n    validate: async ()=>apiCall('/auth/validate', {\n            method: 'POST',\n            body: JSON.stringify({})\n        }),\n    logout: async ()=>apiCall('/auth/logout', {\n            method: 'POST'\n        })\n};\n// User endpoints\nconst userEndpoints = {\n    getProfile: async ()=>apiCall('/user/profile'),\n    updateProfile: async (data)=>apiCall('/user/profile', {\n            method: 'PUT',\n            body: JSON.stringify(data)\n        }),\n    getData: async ()=>apiCall('/user/data')\n};\n// Topics endpoints\nconst topicsEndpoints = {\n    getAll: async ()=>apiCall('/topics'),\n    getById: async (id)=>apiCall(\"/topics/\".concat(id)),\n    getUserProgress: async ()=>apiCall('/topics/progress')\n};\n// Task endpoints  \nconst taskEndpoints = {\n    create: async (taskData)=>apiCall('/tasks', {\n            method: 'POST',\n            body: JSON.stringify(taskData)\n        }),\n    getById: async (taskId)=>apiCall(\"/tasks/\".concat(taskId)),\n    update: async (taskId, updateData)=>apiCall(\"/tasks/\".concat(taskId), {\n            method: 'PUT',\n            body: JSON.stringify(updateData)\n        }),\n    getUserTasks: async (userId)=>apiCall(\"/tasks/user/\".concat(userId))\n};\n// ✅ Flashcard endpoints\nconst flashcardEndpoints = {\n    getByTopicAndLevel: async (topic, level)=>{\n        try {\n            console.log('\\uD83D\\uDE80 Fetching flashcards: topic=\"'.concat(topic, '\", level=\"').concat(level, '\"'));\n            const result = await apiCall(\"/flashcards/\".concat(encodeURIComponent(topic), \"/\").concat(level));\n            if (result && result.success) {\n                console.log(\"✅ Received \".concat(result.data.length, \" flashcards\"));\n                return result.data;\n            } else if (Array.isArray(result)) {\n                console.log(\"✅ Received \".concat(result.length, \" flashcards (direct array)\"));\n                return result;\n            } else {\n                console.error('❌ Unexpected response format:', result);\n                throw new Error('Invalid response format from flashcards API');\n            }\n        } catch (error) {\n            console.error('❌ Error fetching flashcards:', error);\n            throw error;\n        }\n    },\n    create: async (flashcardData)=>apiCall('/flashcards', {\n            method: 'POST',\n            body: JSON.stringify(flashcardData)\n        }),\n    markAsLearned: async (wordId, taskId, topicName)=>apiCall('/flashcards/mark-learned', {\n            method: 'POST',\n            body: JSON.stringify({\n                WordId: wordId,\n                TaskId: taskId,\n                TopicName: topicName\n            })\n        })\n};\n// Words endpoints\nconst wordsEndpoints = {\n    getUnlearned: async function(topic, level) {\n        let randomLimit = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 20;\n        try {\n            console.log('\\uD83D\\uDE80 Fetching unlearned words: topic=\"'.concat(topic, '\", level=\"').concat(level, '\"'));\n            const result = await apiCall(\"/words?topic=\".concat(encodeURIComponent(topic), \"&level=\").concat(level, \"&randomLimit=\").concat(randomLimit, \"&filterLearned=true\"));\n            console.log(\"✅ Received \".concat(Array.isArray(result) ? result.length : 0, \" unlearned words\"));\n            return result;\n        } catch (error) {\n            console.error('❌ Error fetching unlearned words:', error);\n            throw error;\n        }\n    },\n    getLearned: async (topic, level)=>{\n        const params = new URLSearchParams();\n        if (topic) params.append('topic', topic);\n        if (level) params.append('level', level.toString());\n        return apiCall(\"/words/learned?\".concat(params.toString()));\n    },\n    getInTask: async (taskId)=>apiCall(\"/words/in-task?taskId=\".concat(taskId)),\n    addToTask: async (taskId, wordIds)=>apiCall('/words/to-task', {\n            method: 'POST',\n            body: JSON.stringify({\n                taskId,\n                wordIds\n            })\n        })\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n    apiCall,\n    authenticatedApiCall,\n    healthCheck,\n    auth: authEndpoints,\n    user: userEndpoints,\n    topics: topicsEndpoints,\n    tasks: taskEndpoints,\n    flashcards: flashcardEndpoints,\n    words: wordsEndpoints\n});\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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UUFDbkIsZ0JBQW1ENEMsT0FBbkNFLG1CQUFtQkgsUUFBTyxXQUE4QmlCLE9BQXJCaEIsT0FBTSxpQkFBMkIsT0FBWmdCLGFBQVk7WUFHdEZ0RixRQUFRQyxHQUFHLENBQUMsY0FBd0QsT0FBMUMwRSxNQUFNQyxPQUFPLENBQUNMLFVBQVVBLE9BQU9HLE1BQU0sR0FBRyxHQUFFO1lBQ3BFLE9BQU9IO1FBQ1QsRUFBRSxPQUFPdkQsT0FBTztZQUNkaEIsUUFBUWdCLEtBQUssQ0FBQyxxQ0FBcUNBO1lBQ25ELE1BQU1BO1FBQ1I7SUFDRjtJQUVBdUUsWUFBWSxPQUFPbEIsT0FBZ0JDO1FBQ2pDLE1BQU1rQixTQUFTLElBQUlDO1FBQ25CLElBQUlwQixPQUFPbUIsT0FBT0UsTUFBTSxDQUFDLFNBQVNyQjtRQUNsQyxJQUFJQyxPQUFPa0IsT0FBT0UsTUFBTSxDQUFDLFNBQVNwQixNQUFNcUIsUUFBUTtRQUVoRCxPQUFPakUsUUFBUSxrQkFBb0MsT0FBbEI4RCxPQUFPRyxRQUFRO0lBQ2xEO0lBRUFDLFdBQVcsT0FBTzlCLFNBQ2hCcEMsUUFBUSx5QkFBZ0MsT0FBUG9DO0lBRW5DK0IsV0FBVyxPQUFPL0IsUUFBZ0JnQyxVQUNoQ3BFLFFBQVEsa0JBQWtCO1lBQ3hCZ0IsUUFBUTtZQUNSQyxNQUFNQyxLQUFLQyxTQUFTLENBQUM7Z0JBQ25CaUI7Z0JBQ0FnQztZQUNGO1FBQ0Y7QUFDSixFQUFFO0FBRUYsaUVBQWU7SUFDYnBFO0lBQ0FZO0lBQ0FDO0lBQ0F3RCxNQUFNdkQ7SUFDTndELE1BQU05QztJQUNOK0MsUUFBUTNDO0lBQ1I0QyxPQUFPdkM7SUFDUHdDLFlBQVloQztJQUNaaUMsT0FBT2hCO0FBQ1QsQ0FBQyxFQUFDIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXG9yemlsXFxPbmVEcml2ZVxc16nXldec15fXnyDXlNei15HXldeT15RcXDA3MDUyNVxcdW5pdHktdm9pY2UtZnJvbnRlbmQtMVxcc3JjXFxjb25maWdcXGFwaS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyB1bml0eS12b2ljZS1mcm9udGVuZC9zcmMvY29uZmlnL2FwaS50c1xyXG5jb25zdCBBUElfVVJMID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQVBJX1VSTCB8fCAnaHR0cDovL2xvY2FsaG9zdDo1MDAwJztcclxuXHJcbmNvbnNvbGUubG9nKCfwn5SnIEFQSSBDb25maWd1cmF0aW9uOicsIHtcclxuICBORVhUX1BVQkxJQ19BUElfVVJMOiBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19BUElfVVJMLFxyXG4gIEFQSV9VUkw6IEFQSV9VUkwsXHJcbiAgTk9ERV9FTlY6IHByb2Nlc3MuZW52Lk5PREVfRU5WXHJcbn0pO1xyXG5cclxuLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGhhbmRsZSBBUEkgcmVzcG9uc2VzXHJcbmFzeW5jIGZ1bmN0aW9uIGhhbmRsZVJlc3BvbnNlKHJlc3BvbnNlOiBSZXNwb25zZSkge1xyXG4gIGNvbnN0IGNvbnRlbnRUeXBlID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoJ2NvbnRlbnQtdHlwZScpO1xyXG4gIFxyXG4gIGNvbnNvbGUubG9nKGDwn5OhIFJlc3BvbnNlOiAke3Jlc3BvbnNlLnN0YXR1c30gJHtyZXNwb25zZS5zdGF0dXNUZXh0fSwgQ29udGVudC1UeXBlOiAke2NvbnRlbnRUeXBlfWApO1xyXG4gIFxyXG4gIGlmIChjb250ZW50VHlwZSAmJiBjb250ZW50VHlwZS5pbmNsdWRlcygnYXBwbGljYXRpb24vanNvbicpKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG4gICAgICBcclxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xyXG4gICAgICAgIGNvbnN0IGVycm9yT2JqID0ge1xyXG4gICAgICAgICAgc3RhdHVzOiByZXNwb25zZS5zdGF0dXMsXHJcbiAgICAgICAgICBzdGF0dXNUZXh0OiByZXNwb25zZS5zdGF0dXNUZXh0LFxyXG4gICAgICAgICAgbWVzc2FnZTogZGF0YS5tZXNzYWdlIHx8IGRhdGEuZXJyb3IgfHwgJ0FQSSByZXF1ZXN0IGZhaWxlZCcsXHJcbiAgICAgICAgICByZXNwb25zZURhdGE6IGRhdGEsXHJcbiAgICAgICAgICB1cmw6IHJlc3BvbnNlLnVybFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29uc29sZS5lcnJvcign4p2MIEFQSSBFcnJvciAoSlNPTik6JywgZXJyb3JPYmopO1xyXG4gICAgICAgIHRocm93IGVycm9yT2JqO1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICByZXR1cm4gZGF0YTtcclxuICAgIH0gY2F0Y2ggKGpzb25FcnJvcikge1xyXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XHJcbiAgICAgICAgY29uc3QgZXJyb3JPYmogPSB7XHJcbiAgICAgICAgICBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1cyxcclxuICAgICAgICAgIHN0YXR1c1RleHQ6IHJlc3BvbnNlLnN0YXR1c1RleHQsXHJcbiAgICAgICAgICBtZXNzYWdlOiBgRmFpbGVkIHRvIHBhcnNlIEpTT04gcmVzcG9uc2U6ICR7anNvbkVycm9yfWAsXHJcbiAgICAgICAgICByZXNwb25zZURhdGE6IG51bGwsXHJcbiAgICAgICAgICB1cmw6IHJlc3BvbnNlLnVybFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29uc29sZS5lcnJvcign4p2MIEFQSSBFcnJvciAoSlNPTiBQYXJzZSBGYWlsZWQpOicsIGVycm9yT2JqKTtcclxuICAgICAgICB0aHJvdyBlcnJvck9iajtcclxuICAgICAgfVxyXG4gICAgICB0aHJvdyBqc29uRXJyb3I7XHJcbiAgICB9XHJcbiAgfVxyXG4gIFxyXG4gIHRyeSB7XHJcbiAgICBjb25zdCB0ZXh0ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xyXG4gICAgY29uc29sZS5sb2coYPCfk4QgUmVzcG9uc2UgdGV4dCAoZmlyc3QgMjAwIGNoYXJzKTogJHt0ZXh0LnN1YnN0cmluZygwLCAyMDApfWApO1xyXG4gICAgXHJcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XHJcbiAgICAgIGNvbnN0IGVycm9yT2JqID0ge1xyXG4gICAgICAgIHN0YXR1czogcmVzcG9uc2Uuc3RhdHVzLFxyXG4gICAgICAgIHN0YXR1c1RleHQ6IHJlc3BvbnNlLnN0YXR1c1RleHQsXHJcbiAgICAgICAgbWVzc2FnZTogdGV4dCB8fCAnQVBJIHJlcXVlc3QgZmFpbGVkJyxcclxuICAgICAgICByZXNwb25zZURhdGE6IHRleHQsXHJcbiAgICAgICAgdXJsOiByZXNwb25zZS51cmxcclxuICAgICAgfTtcclxuICAgICAgY29uc29sZS5lcnJvcign4p2MIEFQSSBFcnJvciAoVGV4dCk6JywgZXJyb3JPYmopO1xyXG4gICAgICB0aHJvdyBlcnJvck9iajtcclxuICAgIH1cclxuICAgIFxyXG4gICAgcmV0dXJuIHRleHQ7XHJcbiAgfSBjYXRjaCAodGV4dEVycm9yKSB7XHJcbiAgICBjb25zdCBlcnJvck9iaiA9IHtcclxuICAgICAgc3RhdHVzOiByZXNwb25zZS5zdGF0dXMsXHJcbiAgICAgIHN0YXR1c1RleHQ6IHJlc3BvbnNlLnN0YXR1c1RleHQsXHJcbiAgICAgIG1lc3NhZ2U6IGBGYWlsZWQgdG8gcmVhZCByZXNwb25zZTogJHt0ZXh0RXJyb3J9YCxcclxuICAgICAgcmVzcG9uc2VEYXRhOiBudWxsLFxyXG4gICAgICB1cmw6IHJlc3BvbnNlLnVybFxyXG4gICAgfTtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBBUEkgRXJyb3IgKFRleHQgUmVhZCBGYWlsZWQpOicsIGVycm9yT2JqKTtcclxuICAgIHRocm93IGVycm9yT2JqO1xyXG4gIH1cclxufVxyXG5cclxuLy8g4pyFINek15XXoNen16bXmdeUINec16fXkdec16og15jXlden158gLSDXqtee15nXkyDXnmxvY2FsU3RvcmFnZSAo16TXqdeV15gg15nXldeq16gpXHJcbmZ1bmN0aW9uIGdldEF1dGhUb2tlbigpOiBzdHJpbmcgfCBudWxsIHtcclxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgIHJldHVybiBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgndG9rZW4nKTtcclxuICB9XHJcbiAgcmV0dXJuIG51bGw7XHJcbn1cclxuXHJcbi8vIOKchSBNYWluIEFQSSBjYWxsIGZ1bmN0aW9uIC0g15LXmdep15Qg15TXmdeR16jXmdeT15nXqlxyXG5hc3luYyBmdW5jdGlvbiBhcGlDYWxsKGVuZHBvaW50OiBzdHJpbmcsIG9wdGlvbnM6IFJlcXVlc3RJbml0ID0ge30pIHtcclxuICBpZiAoIWVuZHBvaW50LnN0YXJ0c1dpdGgoJy8nKSkge1xyXG4gICAgZW5kcG9pbnQgPSAnLycgKyBlbmRwb2ludDtcclxuICB9XHJcbiAgXHJcbiAgLy8g4pyFINeU15vXnyBoZWFkZXJzXHJcbiAgY29uc3QgdG9rZW4gPSBnZXRBdXRoVG9rZW4oKTtcclxuICBjb25zdCBoZWFkZXJzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge1xyXG4gICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcclxuICAgIC4uLm9wdGlvbnMuaGVhZGVycyBhcyBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+XHJcbiAgfTtcclxuXHJcbiAgLy8g4pyFINeU15XXodejIEF1dGhvcml6YXRpb24gaGVhZGVyINeQ150g15nXqSDXmNeV16fXn1xyXG4gIGlmICh0b2tlbikge1xyXG4gICAgaGVhZGVyc1snQXV0aG9yaXphdGlvbiddID0gYEJlYXJlciAke3Rva2VufWA7XHJcbiAgfVxyXG5cclxuICBjb25zdCBmdWxsVXJsID0gYCR7QVBJX1VSTH0ke2VuZHBvaW50fWA7XHJcbiAgY29uc29sZS5sb2coYPCfmoAgTWFraW5nIEFQSSBjYWxsIHRvOiAke2Z1bGxVcmx9YCwge1xyXG4gICAgaGFzVG9rZW46ICEhdG9rZW4sXHJcbiAgICBlbnZpcm9ubWVudDogcHJvY2Vzcy5lbnYuTk9ERV9FTlZcclxuICB9KTtcclxuXHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goZnVsbFVybCwge1xyXG4gICAgICAuLi5vcHRpb25zLFxyXG4gICAgICBoZWFkZXJzLFxyXG4gICAgICBjcmVkZW50aWFsczogJ2luY2x1ZGUnIC8vINei15PXmdeZ158g15vXldec15wgY29va2llcyDXnNek15nXqteV15cg157Xp9eV157XmVxyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIGF3YWl0IGhhbmRsZVJlc3BvbnNlKHJlc3BvbnNlKTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcihg8J+SpSBBUEkgY2FsbCBmYWlsZWQgZm9yICR7ZW5kcG9pbnR9OmAsIHtcclxuICAgICAgdXJsOiBmdWxsVXJsLFxyXG4gICAgICBlcnJvcjogZXJyb3IsXHJcbiAgICAgIGVycm9yTWVzc2FnZTogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcicsXHJcbiAgICAgIGhlYWRlcnM6IGhlYWRlcnNcclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICBpZiAoZXJyb3IgJiYgdHlwZW9mIGVycm9yID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAoZXJyb3IgYXMgYW55KS5lbmRwb2ludCA9IGVuZHBvaW50O1xyXG4gICAgICAoZXJyb3IgYXMgYW55KS5mdWxsVXJsID0gZnVsbFVybDtcclxuICAgIH1cclxuICAgIFxyXG4gICAgdGhyb3cgZXJyb3I7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYXV0aGVudGljYXRlZEFwaUNhbGwoZW5kcG9pbnQ6IHN0cmluZywgb3B0aW9uczogUmVxdWVzdEluaXQgPSB7fSkge1xyXG4gIHJldHVybiBhcGlDYWxsKGVuZHBvaW50LCBvcHRpb25zKTtcclxufVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGhlYWx0aENoZWNrKCkge1xyXG4gIHJldHVybiBhcGlDYWxsKCcvaGVhbHRoJyk7XHJcbn1cclxuXHJcbi8vIEF1dGhlbnRpY2F0aW9uIGVuZHBvaW50c1xyXG5leHBvcnQgY29uc3QgYXV0aEVuZHBvaW50cyA9IHtcclxuICBsb2dpbjogYXN5bmMgKGNyZWRlbnRpYWxzOiB7IGVtYWlsOiBzdHJpbmc7IHBhc3N3b3JkOiBzdHJpbmcgfSkgPT4gXHJcbiAgICBhcGlDYWxsKCcvYXV0aC9sb2dpbicsIHtcclxuICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGNyZWRlbnRpYWxzKSxcclxuICAgIH0pLFxyXG4gICAgXHJcbiAgcmVnaXN0ZXI6IGFzeW5jICh1c2VyRGF0YToge1xyXG4gICAgZW1haWw6IHN0cmluZztcclxuICAgIHBhc3N3b3JkOiBzdHJpbmc7XHJcbiAgICBmaXJzdE5hbWU/OiBzdHJpbmc7XHJcbiAgICBsYXN0TmFtZT86IHN0cmluZztcclxuICAgIHBob25lTnVtYmVyPzogc3RyaW5nO1xyXG4gICAgZW5nbGlzaExldmVsPzogc3RyaW5nO1xyXG4gICAgYWdlUmFuZ2U/OiBzdHJpbmc7XHJcbiAgICBba2V5OiBzdHJpbmddOiB1bmtub3duO1xyXG4gIH0pID0+IFxyXG4gICAgYXBpQ2FsbCgnL2F1dGgvcmVnaXN0ZXInLCB7XHJcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh1c2VyRGF0YSksXHJcbiAgICB9KSxcclxuICAgIFxyXG4gIHZhbGlkYXRlOiBhc3luYyAoKSA9PlxyXG4gICAgYXBpQ2FsbCgnL2F1dGgvdmFsaWRhdGUnLCB7XHJcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7fSksXHJcbiAgICB9KSxcclxuICAgIFxyXG4gIGxvZ291dDogYXN5bmMgKCkgPT4gXHJcbiAgICBhcGlDYWxsKCcvYXV0aC9sb2dvdXQnLCB7XHJcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgfSlcclxufTtcclxuXHJcbi8vIFVzZXIgZW5kcG9pbnRzXHJcbmV4cG9ydCBjb25zdCB1c2VyRW5kcG9pbnRzID0ge1xyXG4gIGdldFByb2ZpbGU6IGFzeW5jICgpID0+IGFwaUNhbGwoJy91c2VyL3Byb2ZpbGUnKSxcclxuICB1cGRhdGVQcm9maWxlOiBhc3luYyAoZGF0YTogdW5rbm93bikgPT4gXHJcbiAgICBhcGlDYWxsKCcvdXNlci9wcm9maWxlJywge1xyXG4gICAgICBtZXRob2Q6ICdQVVQnLFxyXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShkYXRhKSxcclxuICAgIH0pLFxyXG4gIGdldERhdGE6IGFzeW5jICgpID0+IGFwaUNhbGwoJy91c2VyL2RhdGEnKSxcclxufTtcclxuXHJcbi8vIFRvcGljcyBlbmRwb2ludHNcclxuZXhwb3J0IGNvbnN0IHRvcGljc0VuZHBvaW50cyA9IHtcclxuICBnZXRBbGw6IGFzeW5jICgpID0+IGFwaUNhbGwoJy90b3BpY3MnKSxcclxuICBnZXRCeUlkOiBhc3luYyAoaWQ6IHN0cmluZykgPT4gYXBpQ2FsbChgL3RvcGljcy8ke2lkfWApLFxyXG4gIGdldFVzZXJQcm9ncmVzczogYXN5bmMgKCkgPT4gYXBpQ2FsbCgnL3RvcGljcy9wcm9ncmVzcycpLFxyXG59O1xyXG5cclxuLy8gVGFzayBlbmRwb2ludHMgIFxyXG5leHBvcnQgY29uc3QgdGFza0VuZHBvaW50cyA9IHtcclxuICBjcmVhdGU6IGFzeW5jICh0YXNrRGF0YToge1xyXG4gICAgVXNlcklkOiBzdHJpbmc7XHJcbiAgICBUb3BpY05hbWU6IHN0cmluZztcclxuICAgIExldmVsOiBudW1iZXI7XHJcbiAgICBUYXNrVHlwZTogc3RyaW5nO1xyXG4gICAgU3RhcnREYXRlPzogc3RyaW5nO1xyXG4gIH0pID0+IGFwaUNhbGwoJy90YXNrcycsIHtcclxuICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgYm9keTogSlNPTi5zdHJpbmdpZnkodGFza0RhdGEpLFxyXG4gIH0pLFxyXG4gIGdldEJ5SWQ6IGFzeW5jICh0YXNrSWQ6IHN0cmluZykgPT4gYXBpQ2FsbChgL3Rhc2tzLyR7dGFza0lkfWApLFxyXG4gIHVwZGF0ZTogYXN5bmMgKHRhc2tJZDogc3RyaW5nLCB1cGRhdGVEYXRhOiB1bmtub3duKSA9PiBcclxuICAgIGFwaUNhbGwoYC90YXNrcy8ke3Rhc2tJZH1gLCB7XHJcbiAgICAgIG1ldGhvZDogJ1BVVCcsXHJcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHVwZGF0ZURhdGEpLFxyXG4gICAgfSksXHJcbiAgZ2V0VXNlclRhc2tzOiBhc3luYyAodXNlcklkOiBzdHJpbmcpID0+IGFwaUNhbGwoYC90YXNrcy91c2VyLyR7dXNlcklkfWApLFxyXG59O1xyXG5cclxuLy8g4pyFIEZsYXNoY2FyZCBlbmRwb2ludHNcclxuZXhwb3J0IGNvbnN0IGZsYXNoY2FyZEVuZHBvaW50cyA9IHtcclxuICBnZXRCeVRvcGljQW5kTGV2ZWw6IGFzeW5jICh0b3BpYzogc3RyaW5nLCBsZXZlbDogbnVtYmVyKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zb2xlLmxvZyhg8J+agCBGZXRjaGluZyBmbGFzaGNhcmRzOiB0b3BpYz1cIiR7dG9waWN9XCIsIGxldmVsPVwiJHtsZXZlbH1cImApO1xyXG4gICAgICBcclxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgYXBpQ2FsbChgL2ZsYXNoY2FyZHMvJHtlbmNvZGVVUklDb21wb25lbnQodG9waWMpfS8ke2xldmVsfWApO1xyXG4gICAgICBcclxuICAgICAgaWYgKHJlc3VsdCAmJiByZXN1bHQuc3VjY2Vzcykge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGDinIUgUmVjZWl2ZWQgJHtyZXN1bHQuZGF0YS5sZW5ndGh9IGZsYXNoY2FyZHNgKTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0LmRhdGE7XHJcbiAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShyZXN1bHQpKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coYOKchSBSZWNlaXZlZCAke3Jlc3VsdC5sZW5ndGh9IGZsYXNoY2FyZHMgKGRpcmVjdCBhcnJheSlgKTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBVbmV4cGVjdGVkIHJlc3BvbnNlIGZvcm1hdDonLCByZXN1bHQpO1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCByZXNwb25zZSBmb3JtYXQgZnJvbSBmbGFzaGNhcmRzIEFQSScpO1xyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCfinYwgRXJyb3IgZmV0Y2hpbmcgZmxhc2hjYXJkczonLCBlcnJvcik7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIGNyZWF0ZTogYXN5bmMgKGZsYXNoY2FyZERhdGE6IHtcclxuICAgIFdvcmQ6IHN0cmluZztcclxuICAgIFRyYW5zbGF0aW9uOiBzdHJpbmc7XHJcbiAgICBUb3BpY05hbWU6IHN0cmluZztcclxuICAgIExldmVsPzogbnVtYmVyO1xyXG4gICAgRXhhbXBsZVVzYWdlPzogc3RyaW5nO1xyXG4gIH0pID0+IGFwaUNhbGwoJy9mbGFzaGNhcmRzJywge1xyXG4gICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICBib2R5OiBKU09OLnN0cmluZ2lmeShmbGFzaGNhcmREYXRhKSxcclxuICB9KSxcclxuXHJcbiAgbWFya0FzTGVhcm5lZDogYXN5bmMgKHdvcmRJZDogc3RyaW5nLCB0YXNrSWQ6IHN0cmluZywgdG9waWNOYW1lPzogc3RyaW5nKSA9PiBcclxuICAgIGFwaUNhbGwoJy9mbGFzaGNhcmRzL21hcmstbGVhcm5lZCcsIHtcclxuICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcclxuICAgICAgICBXb3JkSWQ6IHdvcmRJZCxcclxuICAgICAgICBUYXNrSWQ6IHRhc2tJZCxcclxuICAgICAgICBUb3BpY05hbWU6IHRvcGljTmFtZVxyXG4gICAgICB9KSxcclxuICAgIH0pLFxyXG59O1xyXG5cclxuLy8gV29yZHMgZW5kcG9pbnRzXHJcbmV4cG9ydCBjb25zdCB3b3Jkc0VuZHBvaW50cyA9IHtcclxuICBnZXRVbmxlYXJuZWQ6IGFzeW5jICh0b3BpYzogc3RyaW5nLCBsZXZlbDogbnVtYmVyLCByYW5kb21MaW1pdDogbnVtYmVyID0gMjApID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKGDwn5qAIEZldGNoaW5nIHVubGVhcm5lZCB3b3JkczogdG9waWM9XCIke3RvcGljfVwiLCBsZXZlbD1cIiR7bGV2ZWx9XCJgKTtcclxuICAgICAgXHJcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGFwaUNhbGwoXHJcbiAgICAgICAgYC93b3Jkcz90b3BpYz0ke2VuY29kZVVSSUNvbXBvbmVudCh0b3BpYyl9JmxldmVsPSR7bGV2ZWx9JnJhbmRvbUxpbWl0PSR7cmFuZG9tTGltaXR9JmZpbHRlckxlYXJuZWQ9dHJ1ZWBcclxuICAgICAgKTtcclxuICAgICAgXHJcbiAgICAgIGNvbnNvbGUubG9nKGDinIUgUmVjZWl2ZWQgJHtBcnJheS5pc0FycmF5KHJlc3VsdCkgPyByZXN1bHQubGVuZ3RoIDogMH0gdW5sZWFybmVkIHdvcmRzYCk7XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCfinYwgRXJyb3IgZmV0Y2hpbmcgdW5sZWFybmVkIHdvcmRzOicsIGVycm9yKTtcclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgZ2V0TGVhcm5lZDogYXN5bmMgKHRvcGljPzogc3RyaW5nLCBsZXZlbD86IG51bWJlcikgPT4ge1xyXG4gICAgY29uc3QgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xyXG4gICAgaWYgKHRvcGljKSBwYXJhbXMuYXBwZW5kKCd0b3BpYycsIHRvcGljKTtcclxuICAgIGlmIChsZXZlbCkgcGFyYW1zLmFwcGVuZCgnbGV2ZWwnLCBsZXZlbC50b1N0cmluZygpKTtcclxuICAgIFxyXG4gICAgcmV0dXJuIGFwaUNhbGwoYC93b3Jkcy9sZWFybmVkPyR7cGFyYW1zLnRvU3RyaW5nKCl9YCk7XHJcbiAgfSxcclxuXHJcbiAgZ2V0SW5UYXNrOiBhc3luYyAodGFza0lkOiBzdHJpbmcpID0+IFxyXG4gICAgYXBpQ2FsbChgL3dvcmRzL2luLXRhc2s/dGFza0lkPSR7dGFza0lkfWApLFxyXG5cclxuICBhZGRUb1Rhc2s6IGFzeW5jICh0YXNrSWQ6IHN0cmluZywgd29yZElkczogc3RyaW5nW10pID0+XHJcbiAgICBhcGlDYWxsKCcvd29yZHMvdG8tdGFzaycsIHtcclxuICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcclxuICAgICAgICB0YXNrSWQsXHJcbiAgICAgICAgd29yZElkc1xyXG4gICAgICB9KSxcclxuICAgIH0pLFxyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIGFwaUNhbGwsXHJcbiAgYXV0aGVudGljYXRlZEFwaUNhbGwsXHJcbiAgaGVhbHRoQ2hlY2ssXHJcbiAgYXV0aDogYXV0aEVuZHBvaW50cyxcclxuICB1c2VyOiB1c2VyRW5kcG9pbnRzLFxyXG4gIHRvcGljczogdG9waWNzRW5kcG9pbnRzLFxyXG4gIHRhc2tzOiB0YXNrRW5kcG9pbnRzLFxyXG4gIGZsYXNoY2FyZHM6IGZsYXNoY2FyZEVuZHBvaW50cyxcclxuICB3b3Jkczogd29yZHNFbmRwb2ludHMsXHJcbn07Il0sIm5hbWVzIjpbIkFQSV9VUkwiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfQVBJX1VSTCIsImNvbnNvbGUiLCJsb2ciLCJOT0RFX0VOViIsImhhbmRsZVJlc3BvbnNlIiwicmVzcG9uc2UiLCJjb250ZW50VHlwZSIsImhlYWRlcnMiLCJnZXQiLCJzdGF0dXMiLCJzdGF0dXNUZXh0IiwiaW5jbHVkZXMiLCJkYXRhIiwianNvbiIsIm9rIiwiZXJyb3JPYmoiLCJtZXNzYWdlIiwiZXJyb3IiLCJyZXNwb25zZURhdGEiLCJ1cmwiLCJqc29uRXJyb3IiLCJ0ZXh0Iiwic3Vic3RyaW5nIiwidGV4dEVycm9yIiwiZ2V0QXV0aFRva2VuIiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsImFwaUNhbGwiLCJlbmRwb2ludCIsIm9wdGlvbnMiLCJzdGFydHNXaXRoIiwidG9rZW4iLCJmdWxsVXJsIiwiaGFzVG9rZW4iLCJlbnZpcm9ubWVudCIsImZldGNoIiwiY3JlZGVudGlhbHMiLCJlcnJvck1lc3NhZ2UiLCJFcnJvciIsImF1dGhlbnRpY2F0ZWRBcGlDYWxsIiwiaGVhbHRoQ2hlY2siLCJhdXRoRW5kcG9pbnRzIiwibG9naW4iLCJtZXRob2QiLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsInJlZ2lzdGVyIiwidXNlckRhdGEiLCJ2YWxpZGF0ZSIsImxvZ291dCIsInVzZXJFbmRwb2ludHMiLCJnZXRQcm9maWxlIiwidXBkYXRlUHJvZmlsZSIsImdldERhdGEiLCJ0b3BpY3NFbmRwb2ludHMiLCJnZXRBbGwiLCJnZXRCeUlkIiwiaWQiLCJnZXRVc2VyUHJvZ3Jlc3MiLCJ0YXNrRW5kcG9pbnRzIiwiY3JlYXRlIiwidGFza0RhdGEiLCJ0YXNrSWQiLCJ1cGRhdGUiLCJ1cGRhdGVEYXRhIiwiZ2V0VXNlclRhc2tzIiwidXNlcklkIiwiZmxhc2hjYXJkRW5kcG9pbnRzIiwiZ2V0QnlUb3BpY0FuZExldmVsIiwidG9waWMiLCJsZXZlbCIsInJlc3VsdCIsImVuY29kZVVSSUNvbXBvbmVudCIsInN1Y2Nlc3MiLCJsZW5ndGgiLCJBcnJheSIsImlzQXJyYXkiLCJmbGFzaGNhcmREYXRhIiwibWFya0FzTGVhcm5lZCIsIndvcmRJZCIsInRvcGljTmFtZSIsIldvcmRJZCIsIlRhc2tJZCIsIlRvcGljTmFtZSIsIndvcmRzRW5kcG9pbnRzIiwiZ2V0VW5sZWFybmVkIiwicmFuZG9tTGltaXQiLCJnZXRMZWFybmVkIiwicGFyYW1zIiwiVVJMU2VhcmNoUGFyYW1zIiwiYXBwZW5kIiwidG9TdHJpbmciLCJnZXRJblRhc2siLCJhZGRUb1Rhc2siLCJ3b3JkSWRzIiwiYXV0aCIsInVzZXIiLCJ0b3BpY3MiLCJ0YXNrcyIsImZsYXNoY2FyZHMiLCJ3b3JkcyJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/config/api.ts\n"));

/***/ })

});